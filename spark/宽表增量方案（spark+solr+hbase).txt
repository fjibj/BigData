基表到宽表的增量更新算法：
宽表S： key|A|B|C|D|E|F|.......
基表A、B、C、D、E、F.......
S = A join B join C join D join E join F .......
A：IDA|.....|IDB
B：IDB|....|IDC
........
E:  IDE|......|IDF
.......
宽表的索引：key|IDA|IDB|IDC|IDE|IDF|......   允许某字段为空但需要占位
宽表增量更新基本思路：按join链顺序，用各个基表增量表去更新宽表。
算法：（用X表示某个基表，X+表示基表增量表）
按join链顺序取一个基表X
1. 读取X+某个时段的数据为hbaseRDD,记作hbaseRddX
2.遍历hbaseRddX,取出每条记录的IDX、IDY（假定X join Y, IDY是Y表的主键，也是X的外键）作如下处理：
DS作为结果集（字段与宽表相同）;
for (x in hbaseRddX ) do {
    从宽表索引中获取包含x.idx的记录的key的集合，称为F(ront);
    从宽表索引中获取包含x.idy的记录的key的集合，称为E(nd);
    分情况处理：
    （1）F为空且E为空，DS中新增一条记录，key随机生成,x填入相应字段(其他字段为空）；生成索引key||||idx|idy|||（其他字段为空）；
    （2）F不空E空，从S表中读取key在F中的所有记录，将其X部分更新为x,并将更新后的内容添加入DS；
    （3）F不空E不空且F包含于E（含F=E），从S表中读取key在F中的所有记录，将其X部分更新为x,并将更新后的内容添加入DS；
    （4）F不空E不空但F与E无交集，从S表中读取key在F中的所有记录rddF，将其X部分更新为x,从S表中读取key在E中的一条记录，将其内容复制到rddF中，注意不能覆盖rddF记录中已有的字段。
    （5）F不空E不空且F真包含E，从S表中读取key在F中的所有记录rddF，将其X部分更新为x,从S表中读取key在E中的一条记录，将其内容复制到rddF中，注意只复制Y及Y在join链中的后向基表对应的字段。
    （6）F空E不空，DS中新增一条记录r，key随机生成,x填入相应字段，从S表中读取key在E中的一条记录，将其内容复制到r中，注意只复制Y及Y在join链中的后向基表对应的字段。
}
将DS更新到宽表S；
取join链中下一基表增量表进行处理，直到join链中的基表增量表都处理完。

为了使宽表数据均匀分布，rowkey建议采用该宽表的主基表ID的反转，这样可以充分利用预分区，使数据尽可能均匀分布到各个不同的region。
1. 基表到宽表全量，需要修改宽表rowkey生成代码
2. 基表到宽表增量，对rdd中有主基表ID的记录宽表rowkey用主基表ID反转；对无主基表ID的宽表rowkey用UUID，但一旦补充了主基表信息则需要重新生成宽表rowkey(并删除原UUID记录）

注：由于求交集较慢，改进如下：
for (x in hbaseRddX ) do {
    从宽表索引中获取同时包含x.idx和x.idy的记录的key的集合，
    如果不空，从S表中读取key在F中的所有记录，将其X部分更新为x,并将更新后的内容添加入DS；
    否则（即集合为空）：
    	从宽表索引中获取包含x.idx的记录的key的集合，称为F(ront);
    	从宽表索引中获取包含x.idy的记录的key的集合，称为E(nd);
    	分情况处理：
    	（1）F为空且E为空，DS中新增一条记录，key随机生成,x填入相应字段(其他字段为空）；生成索引key||||idx|idy|||（其他字段为空）；
    	（2）F不空E空，从S表中读取key在F中的所有记录，将其X部分更新为x,并将更新后的内容添加入DS；
    	（3）F空E不空，DS中新增一条记录r，key随机生成,x填入相应字段，从S表中读取key在E中的一条记录，将其内容复制到r中，注意只复制Y及Y在join链中的后向基表对应的字段；
    	（4）F不空E不空但F与E无交集（可以不用求交集，此种情况视为ELSE），从S表中读取key在F中的所有记录rddF，将其X部分更新为x,从S表中读取key在E中的一条记录，将其内容复制到rddF中，注意不能覆盖rddF记录中已有的字段。
}
